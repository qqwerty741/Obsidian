```c++
class Base {
public:
	int x_;
}
class A : public Base{}
class B : public Base{}
class Der : public A, public B{};

...

Der f;
std::cout << f.x_; // ОШИБКА, МНОГА x_ 
```

Исправим либо
```c++
std::cout << f.A::x_ << f.B::x_;
```
Либо 
```c++
class A : virtual Base{};
class B : virtual Base{};
class Der : public A, public B {};
```

`virtual` гарантирует, что будет создан только один объект

### Полиморфизм
- **Параметрический** - тип не упоминается, одинаковый код (одна функция для всех типов) (звездочка)
- **``Ad-hoc``** - для разных несовместимых типов разный код под единым интерфейсом (просто перегружаем и не е мозги), пытается косить под Параметрический (перегрузка, приведение типов, шаблоны, наследование)
	- **Статический** - компилятор знает в ``compile time`` как код будет выполняться (перегрузка, приведение типов, раскрытие шаблонов)
	- **Динамический** - мы нихера не знаем и узнаем только после запуска, и то в лучшем случае (наследование)
```c++
class A{};
class B : public A{};

A* ptr;
A a;
B b;
ptr = &a; // ok
ptr = &b; // ok
// таким образом мы можем через указатели юзать методы класса А
```
### Виртуальные функции
>Виртуальный метод(функция) - метод класса, который может быть переопределен в классах наследниках так, что конкретная реализация метода для вызова будет определяться во время исполнения
>Помечается `virtual`

```c++
class Base{
public:
void who(){std::cout << "Base";}
}
class Der : public base{
public:
void who() {std::cout << "Der";}
}

```

Если через указатель на `Base*`, то вывод будет одинаковым.
Если перед каждой функцией писать `virtual`, то мы получаем вывод нормальный, тобеж 
```c++
Base b;
Der t;

Base* ptr;
ptr = b;
ptr->who(); // "Base"
ptr = t;
ptr->who(); // "Der"
```

>Если виртуальная функция переопределена в производном классе, ее называют переопределенной, при этом это не является частным случаем перегрузки

>В перегрузке разные параметры, в переопределении - одинаковые

>Виртуальная функция не может быть `friend`, но может быть таковым для другого класса


> **Конструкторы** не должны быть виртуальными
> **Деструкторы** могут и в идеале должны быть виртуальными


